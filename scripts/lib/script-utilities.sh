#!/bin/sh
#
# script-utilities.sh - Utility functions for generated scripts
#
# This library provides bulletproof, production-ready functions that should be
# included in all scripts generated by the DevOps Productivity Suite.
#
# Usage: source scripts/lib/script-utilities.sh

# Colors for output
if [ -t 1 ]; then
    GREEN='\033[0;32m'
    RED='\033[0;31m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    RESET='\033[0m'
else
    GREEN=''
    RED=''
    YELLOW=''
    BLUE=''
    RESET=''
fi

# ============================================================================
# 1. INPUT SANITIZATION & SECURITY
# ============================================================================

# Sanitize user input (alphanumeric, dots, dashes, underscores only)
sanitize_input() {
    echo "$1" | sed 's/[^a-zA-Z0-9._-]//g'
}

# Sanitize file paths (prevent directory traversal)
sanitize_path() {
    echo "$1" | sed 's/\.\.//g' | sed 's|^/||'
}

# Validate URL format
is_valid_url() {
    echo "$1" | grep -qE '^https?://[a-zA-Z0-9.-]+(:[0-9]+)?(/.*)?$'
}

# Validate port number (1024-65535)
validate_port() {
    local port="$1"
    if [ -z "$port" ]; then
        return 1
    fi
    # Check if numeric
    if ! echo "$port" | grep -qE '^[0-9]+$'; then
        return 1
    fi
    # Check range
    if [ "$port" -lt 1024 ] || [ "$port" -gt 65535 ]; then
        return 1
    fi
    return 0
}

# ============================================================================
# 2. DEPENDENCY MANAGEMENT
# ============================================================================

# Check if npm package is installed
check_npm_package() {
    local dir="${1:-.}"
    local package="$2"
    [ -d "$dir/node_modules/$package" ] || [ -f "$dir/node_modules/$package/package.json" ]
}

# Install npm package if missing
install_npm_package() {
    local dir="${1:-.}"
    local package="$2"
    
    if ! check_npm_package "$dir" "$package"; then
        echo "${YELLOW}Installing $package...${RESET}"
        (cd "$dir" && npm install "$package" --save --silent 2>/dev/null || npm install "$package" --save-dev --silent 2>/dev/null)
        return $?
    fi
    return 0
}

# Check if Python package is installed
check_python_package() {
    local package="$1"
    python3 -c "import $package" 2>/dev/null || python -c "import $package" 2>/dev/null
}

# Install Python package if missing
install_python_package() {
    local package="$1"
    
    if ! check_python_package "$package"; then
        echo "${YELLOW}Installing $package...${RESET}"
        pip3 install "$package" --quiet 2>/dev/null || pip install "$package" --quiet 2>/dev/null
        return $?
    fi
    return 0
}

# Auto-detect and install npm dependencies from package.json
install_npm_deps() {
    local dir="${1:-.}"
    
    if [ -f "$dir/package.json" ] && [ ! -d "$dir/node_modules" ]; then
        echo "${BLUE}Installing npm dependencies...${RESET}"
        (cd "$dir" && npm install --silent)
        return $?
    fi
    return 0
}

# Auto-detect and install Python dependencies from requirements.txt
install_python_deps() {
    local dir="${1:-.}"
    
    if [ -f "$dir/requirements.txt" ]; then
        echo "${BLUE}Installing Python dependencies...${RESET}"
        (cd "$dir" && pip3 install -r requirements.txt --quiet 2>/dev/null || pip install -r requirements.txt --quiet 2>/dev/null)
        return $?
    fi
    return 0
}

# ============================================================================
# 3. SERVICE HEALTH CHECKS
# ============================================================================

# Check if Docker daemon is running
check_docker_daemon() {
    if ! docker info >/dev/null 2>&1; then
        echo "${RED}Error: Docker daemon is not running${RESET}" >&2
        echo "Please start Docker Desktop and try again" >&2
        return 1
    fi
    return 0
}

# Check if port is available (not in use)
check_port_available() {
    local port="$1"
    
    if ! validate_port "$port"; then
        echo "${RED}Error: Invalid port number: $port${RESET}" >&2
        return 1
    fi
    
    if command -v lsof >/dev/null 2>&1; then
        if lsof -ti ":$port" >/dev/null 2>&1; then
            echo "${YELLOW}Warning: Port $port is already in use${RESET}" >&2
            return 1
        fi
    elif command -v netstat >/dev/null 2>&1; then
        if netstat -an | grep -q ":$port "; then
            echo "${YELLOW}Warning: Port $port is already in use${RESET}" >&2
            return 1
        fi
    fi
    return 0
}

# Wait for service to be available
wait_for_service() {
    local url="$1"
    local max_attempts="${2:-30}"
    local delay="${3:-1}"
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        if command -v curl >/dev/null 2>&1; then
            if curl -f -s "$url" >/dev/null 2>&1; then
                return 0
            fi
        elif command -v wget >/dev/null 2>&1; then
            if wget -q --spider "$url" 2>/dev/null; then
                return 0
            fi
        fi
        sleep "$delay"
        attempt=$((attempt + 1))
    done
    
    echo "${RED}Error: Service at $url did not become available after ${max_attempts} attempts${RESET}" >&2
    return 1
}

# ============================================================================
# 4. ERROR HANDLING & RECOVERY
# ============================================================================

# Handle error with clear message
handle_error() {
    local message="$1"
    local exit_code="${2:-1}"
    
    echo "${RED}Error: $message${RESET}" >&2
    exit "$exit_code"
}

# Retry command with exponential backoff
retry_command() {
    local max_retries="${1:-3}"
    local delay="${2:-2}"
    shift 2
    local command="$@"
    local attempt=1
    
    while [ $attempt -le $max_retries ]; do
        if eval "$command"; then
            return 0
        fi
        
        if [ $attempt -lt $max_retries ]; then
            echo "${YELLOW}Attempt $attempt failed, retrying in ${delay}s...${RESET}" >&2
            sleep "$delay"
            delay=$((delay * 2))  # Exponential backoff
        fi
        
        attempt=$((attempt + 1))
    done
    
    echo "${RED}Error: Command failed after $max_retries attempts: $command${RESET}" >&2
    return 1
}

# Cleanup function (can be overridden)
cleanup_on_exit() {
    # Override this in scripts that need cleanup
    :
}

# Setup trap for cleanup
setup_cleanup() {
    trap cleanup_on_exit EXIT INT TERM
}

# ============================================================================
# 5. ENVIRONMENT VARIABLE LOADING
# ============================================================================

# Load environment variables from .env file
load_env_file() {
    local env_file="${1:-.env}"
    
    if [ -f "$env_file" ]; then
        # Export variables, skipping comments and empty lines
        set -a
        # shellcheck source=/dev/null
        . "$env_file"
        set +a
        return 0
    else
        echo "${YELLOW}Warning: No $env_file file found, using defaults${RESET}" >&2
        return 1
    fi
}

# ============================================================================
# 6. PORT CONFIGURATION & SYNCHRONIZATION
# ============================================================================

# Load port configuration (from port-config.sh if available, or defaults)
load_port_config() {
    if [ -f "scripts/lib/port-config.sh" ]; then
        # shellcheck source=/dev/null
        . scripts/lib/port-config.sh
    else
        # Default ports if config not available
        FRONTEND_PORT=${FRONTEND_PORT:-3000}
        BACKEND_PORT=${BACKEND_PORT:-${PORT:-3030}}
        AUTOMATION_PORT=${AUTOMATION_PORT:-7070}
        METRICS_PORT=${METRICS_PORT:-9091}
        
        export FRONTEND_PORT BACKEND_PORT AUTOMATION_PORT METRICS_PORT
    fi
}

# Validate all ports in configuration
validate_all_ports() {
    local failed=0
    
    for port_var in FRONTEND_PORT BACKEND_PORT AUTOMATION_PORT METRICS_PORT; do
        eval "port=\$$port_var"
        if [ -n "$port" ]; then
            if ! validate_port "$port"; then
                echo "${RED}Error: Invalid port in $port_var=$port${RESET}" >&2
                failed=1
            fi
        fi
    done
    
    return $failed
}

# ============================================================================
# 7. LOGGING
# ============================================================================

# Log info message
log_info() {
    echo "${BLUE}[INFO]${RESET} $*"
}

# Log warning message
log_warn() {
    echo "${YELLOW}[WARN]${RESET} $*"
}

# Log error message
log_error() {
    echo "${RED}[ERROR]${RESET} $*" >&2
}

# Log success message
log_success() {
    echo "${GREEN}[SUCCESS]${RESET} $*"
}
